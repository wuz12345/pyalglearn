# 这个文件主要关于动态规划问题
# 问题如下：
# 1、硬币兑换问题
import time
def coin_change(S,n):
    """
    硬币兑换可以看作是找零问题：
    假设你是一家超市的售货员，你需要为顾客找零N元，而你只有固定面额但不限数量的纸币
    请问共有几种方式找零？
    例如：你需要找零4元，不限量的固定纸币面额为1元、2元、3元，则共有以下几种方法：
    [1,3],[2,2],[2,1,1],[1,1,1,1]
    再比如，需要找零十元，纸币面额为2、3、5，则有以下几种方法:
    [2,3,5],[2,2,2,2,2],[5,5],[3,3,2,2]
    :param S: 纸币面额
    :param n: 找零面额
    :return: 次数

    """
    if n < 0:
        return -1
    table = [0]*(n+1)
    """
    解决思路：
    本题是一个动态规划问题
    在给定S的情况下以T[S,n]表示n在S下的方法数量，假定S=[S1,S2,...,Sm]，则：
    T[S,n] = T[[S2,..,Sm],n]+T[S,n-S1]
    上面的公式表示找零n元的方法包含结果中存在至少一个S1(T[S,n-S1])和不存在S1(T[[S2,...,Sm],n]).
    以S=[2,3,5] n=10 为例：
    T[[2,3,5],10] = T[[2,3,5],8]+T[[3,5],10]
                  = T[[2,3,5],6] + T[[3,5],8] + T[[3,5],7] + T[[5],10]
                  = T[[2,3,5],4] + T[[3,5],6] + T[[3,5],5] + T[[5],8]->0 + T[[3,5],4] + T[[5],7]->0 + T[[],10]->0 + T[[5],5]->1
                  = T[[2,3,5],4] + T[[3,5],6] + T[[3,5],5] + T[[3,5],4] + 1
                  = T[[2,3,5],2] + T[[3,5],4]->0 + T[[3,5],3] + T[[5],6]->0 + T[[3,5],2]->0 + T[[5],5]->1 + T[[3,5],1]->0 +T[[5],4]->0 +1
                  = T[[2,3,5],2] + T[[3,5],3] + 2
                  = T[[2,3,5],0]->1 + T[[3,5],2]->0 + T[[3,5],0]->1 + T[[5],3]->0 +2
                  = 4
    上面的方法是自上而下的方法，下面介绍以下自下而上的方法：
    仍然给定S=[S1,S2,S3,...,Sm] ,n
    先考虑只有S=[S1]，接着考虑S =[S1,S2]的情况，以此类推直至S=[S1,...,Sm]的情况
    仍然以S=[2,3,5] n=10 为例:
    S=[2]时：只考虑小于n的情况
    ____| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
      2 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1  |
    只有2时 0，2，4，6，8，10可被找零次数只有一次
    S=[2,3]时：
    ____| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
      2 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1  |
      3 | 1 | 0 | 1 | 1 | 1 | 1 | 2 | 2 | 2 | 2 | 3 |
    上述情况中:
    由于3的如n<3的情况不会受影响，n>=3的情况需要更新
    n = 0, T[[2,3],0] = 1; n = 1, T[[2,3],1] = 0; n = 2, T[[2,3],2] = 1;
    n = 3, T[[2,3],3] = T[[2],3]->0 + T[[2,3],0]->1 = 1
    n = 4, T[[2,3],4] = T[[2],4]->1 + T[[2,3],1]->0 = 1
    n = 5, T[[2,3],5] = T[[2],5]->0 + T[[2,3],2]->1 = 1
    n = 6, T[[2,3],6] = T[[2],6]->1 + T[[2,3],3]->1 = 2
    n = 7, T[[2,3],7] = T[[2],7]->0 + T[[2,3],4]->1 = 1
    n = 8, T[[2,3],8] = T[[2],8]->1 + T[[2,3],5]->1 = 2
    n = 9, T[[2,3],9] = T[[2],9]->0 + T[[2,3],6]->2 = 2
    n = 10, T[[2,3],10] = T[[2],10]->1 + T[[2,3],7]->1 = 2
    S = [2,3,4],同上，对于n<4次数不变，n>=4更新
    n = 0, T[[2,3,4],0] = 1; n = 1, T[[2,3,4],1] = 0; n = 2, T[[2,3,4],2] = 1; n = 3, T[[2,3,4],3] = 1;
    n = 4, T[[2,3,4],4] = T[[2,3,4],0]->1 + T[[2,3],4]->1 = 2
    n = 5, T[[2,3,4],5] = T[[2,3,4],1]->0 + T[[2,3],5]->1 = 1
    n = 6, T[[2,3,4],6] = T[[2,3,4],2]->1 + T[[2,3],6]->2 = 3
    n = 7, T[[2,3,4],7] = T[[2,3,4],3]->1 + T[[2,3],7]->2 = 3
    n = 8, T[[2,3,4],8] = T[[2,3,4],4]->2 + T[[2,3],8]->2 = 4
    n = 9, T[[2,3,4],9] = T[[2,3,4],5]->1 + T[[2,3],9]->2 = 3
    n = 10, T[[2,3,4],10] = T[[2,3,4],6]->3 + T[[2,3],10]->1 = 4
    
    """
    table[0] = 1
    for value in S:
        for j in range(value,n+1):
            table[j] += table[j-value]

    return table[n]
def abbr(a: str, b: str) -> bool:
    """
    """
    n = len(a)
    m = len(b)
    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]
    dp[0][0] = True
    for i in range(n):
        for j in range(m + 1):
            if dp[i][j]:
                if j < m and a[i].upper() == b[j]:
                    dp[i + 1][j + 1] = True
                if a[i].islower():
                    dp[i + 1][j] = True
    return dp[n][m]
def find2():
    i=0
    while True:
        index = pow(2,i)
        if index%3 ==0:
            print(index)
            break
        else:
            print(i,index)
            time.sleep(1)
            i = i+1


if __name__=="__main__":
    # print(coin_change([3,2,5],100))
    # print(coin([3,2,5], 100))
    find2()
    # print(abbr("bcdef","CF"))




